import { CategoryToProfileMap, Compound, Profile, Radius } from '@findy-sources/meta';
/**
 * Mapping function that accepts value and returns dictionary of properties or undefined.
 */
export declare type ArrayMappingFunction<T> = (value: T[]) => any[] | undefined;
/**
 * Dictionary that maps internal constants to foreign.
 *
 * Recommended specific type is `Records<string, string[]>`.
 * M.FilterMap can be used to fix and check keys if dictionary is for specific filter.
 *
 * Dictionaries like this is used by mapAll, mapSome, reverseMapOne, reverseMapSome.
 *
 *     transmission: M.FilterMap<typeof filters.auto.transmission> = {
 *       Automanual: ['AUT'],
 *       Automatic: ['AUT'],
 *       CVT: ['AUT'],
 *       Manual: ['MAN']
 *     }
 */
export declare type MappingDictionary = Record<string, any>;
export declare type ProfileSpec<T> = NodeSpec<T, T> & {
    profile?: (value: T, profile: T, params?: object) => object | undefined;
};
export declare type NodeSpec<Profile, Node> = {
    [K in keyof Node]?: NodeSpec<Profile, Node[K]> | ((value: Node[K], profile: Profile, params?: object) => object | undefined);
};
export declare type ProfileRadius = {
    geolocation: {
        radius: Radius;
    };
};
/**
 * Mapping specification
 *
 * Keys of specification are category names. Mapping will not run if profile category is not listed.
 *
 * There is one special key "any". It will run before other sections and it's results can be overriden by specific category section.
 *
 * Structure of a section is the same as profile with one exception: radius is the part of geolocation object.
 *
 * Values of specification are mapping functions. Mapping function accepts 3 parameters:
 * - value of profile field. For spec `{ product: { price: f } }` function f will run with first `profile.price` as first argument. If there is no value by given path - function will not run
 * - profile
 * - assets - all properties built from previous mapping runs combined
 *
 * If any of mapping functions returns undefined, it's considered that profile can not and should not be used. I.e. source does not support it.
 *
 * After runs of all mapping function it's combined assets are passed to variants function.
 *
 * Variants function accepts built assets and returns array of functions to retrieve data (variant functions).
 * All previous steps should be lightweight, they are not allowed to access network. Heavy work like accessing network is allowed only in variant function.
 *
 * Variant function receives context. Specific structure of it depends on context helper used, for most cases it's page number and request function.
 *
 *     const spec: M.MappingSpec = {
 *       product: {}, // Respond to product category
 *       'product:apparel': {}, // Respond to product:apparel category
 *       'product:household': {}, // Respond to product:household category
 *       any: { // "any" sections runs first and can be to override it's results
 *         geolocation: {
 *           country: M.allow('US'), // Source supports only the US country
 *           radius: {
 *             min: M.pipe(M.allowIf(x => x === 0), M.noProp) // Source supports profile only if profile.geolocation.radius == 0
 *           }
 *         },
 *         price: {
 *           min: M.pipe(M.allowIf(min => min < 400), M.toProp('price')) // adds to assets `{ price: profile.price.min }` if min price is less then 400
 *         },
 *         profile: () => ({ // profile is another special prop. It runs with whole profile before more specific mapping functions.
 *           _origin: 'http://example.com',
 *           _path: '/v2/api'
 *         })
 *       },
 *       variants: (assets: any) => { // in this example with have one variant, return array of one element
 *         return [({ page, request }) =>
 *           request({
 *             page: page + 1,
 *             ...assets
 *           })
 *         ]
 *       }
 *     }
 */
export declare type MappingSpec<R = Promise<string>> = {
    [K in keyof CategoryToProfileMap]?: ProfileSpec<CategoryToProfileMap[K] & ProfileRadius>;
} & {
    variants: (assets: any) => ((...args: any[]) => R)[];
};
/**
 * Creates mapping function according to specification.
 *
 * Created function returns array of mapping variants
 *
 *     const spec: M.MappingSpec = {
 *       // mapping specification
 *     }
 *     export const variants = M.specToVariants(spec)
 */
export declare function specToVariants<R>(mapping: MappingSpec<R>): (profile: Profile, radius?: Radius) => ((...args: any[]) => R)[];
/**
 * Creates a function that transforms array according to the dictionary.
 *
 * Values missed in the dictionary will be removed. If no values was mapped, return undefined.
 * Arrays in results will be flattened.
 *
 *     import { filters } from '@findy-sources/meta'
 *     const foo: M.FilterMap<typeof filters.bar.baz> = {
 *       a: 'AA',
 *       b: 'BB',
 *       c: 'CC'
 *     }
 *     const f = mapSome(foo)
 *     f(['a']) // (['AA'])
 */
export declare function mapSome<M extends MappingDictionary>(mapping: M): ArrayMappingFunction<keyof M>;
/**
 * Creates a function that transforms array according to the dictionary.
 *
 * If some values was not found in the dictionary returns undefined.
 * Arrays in results will be flattened.
 *
 *     const foo: M.FilterMap<typeof filters.bar.baz> = {
 *       a: 'AA',
 *       b: 'BB'
 *     }
 *     const f = mapAll(foo)
 *
 *     f(['a','b']) // (['AA','BB'])
 *
 *     f(['a', 'b', 'c']) // undefined
 */
export declare function mapAll<M extends MappingDictionary>(mapping: M): ArrayMappingFunction<keyof M>;
export declare type ReverseMapOneFunction = (value: string) => string | undefined;
/**
 * Creates a function that transforms value according to the reversed dictionary.
 *
 * If value was not found returns undefined.
 *
 *     const foo: M.FilterMap<typeof filters.bar.baz> = {
 *       a: 'AA',
 *       b: 'BB'
 *     }
 *     const f = reverseMapOne(foo)
 *     f('AA') // ('a')
 */
export declare function reverseMapOne(mapping: MappingDictionary): ReverseMapOneFunction;
export declare type ReverseMapSomeFunction = (value: (string | number)[]) => (string)[] | undefined;
/**
 * Creates a function that transforms array according to the reversed dictionary.
 *
 * Values missed in the dictionary will be removed. If no values was mapped returns undefined.
 *
 *     const foo: M.FilterMap<typeof filters.bar.baz> = {
 *       a: 'AA',
 *       b: 'BB',
 *       c: 'CC'
 *     }
 *     const f = reverseMapSome(seller)
 *     f(['AA','CC']) // (['a','c'])
 */
export declare function reverseMapSome(mapping: MappingDictionary): ReverseMapSomeFunction;
export declare type ToPropFunction<T> = (value: T) => Record<string, T>;
/**
 * Creates a function that converts the value to an object with a single property of given name.
 *
 * Normally used on the last step of mapping pipe. undefined value will return undefined.
 *
 *     const f = toProp('foo')
 *     f(42) // ({ foo: 42 })
 */
export declare function toProp<T>(name: string): ToPropFunction<T>;
/**
 * Creates a function that selects dictionary from categoryMap according to profile category.
 *
 * Returns undefined if no match was found and default not specified.
 */
export declare function switchCategory(categoryMap: Record<string, Function>): (value: any, profile: any) => any;
export declare type AllowFunction<T> = (value: T) => {} | undefined;
/**
 * Creates a function that checks whether allowedValues includes the checked value.
 *
 * Created function returns empty object if allowedValues does not include given value, otherwise returns undefined.
 * This function is a shortcut for `M.pipe(M.allowIf(x => allowedValues.includes(x)), M.noProp)`
 *
 *     const f = allow('US', 'CA')
 *     f('US') // {}
 *     f('UK') // undefined
 */
export declare function allow<T>(...allowedValues: any[]): AllowFunction<T>;
/**
 * Merges the value into the params.
 *
 * Can be used in the last position of mapping pipe (after M.toProp) to merge properties instead of overriding.
 *
 *     const foo = ['FOO']
 *     const bar = ['BAR']
 *     const x = pipe(toProp('baz'), merge)(foo, {}, undefined) // { baz: ['FOO'] }
 *     const y = pipe(toProp('baz'), merge)(bar, {}, x) // { baz: ['FOO', 'BAR'] }
 *
 *     const foo = { attr1: 'FOO' }
 *     const bar = { attr2: 'BAR' }
 *     const x = M.pipe(M.toProp('baz'), M.merge)(foo, {}, undefined) // { baz: { attr1: 'FOO' } }
 *     const y = M.pipe(M.toProp('baz'), M.merge)(bar, {}, x) // { baz: { attr1: 'FOO', attr2: 'BAR' } }
 */
export declare function merge(value: Record<string, any>, profile: any, params?: Record<string, any>): Pick<object, string>;
/**
 * Determines local distance unit from `profile.country` and converts distance to local units if required.
 *
 *     const profile = { geolocation: { country: 'US' } }
 *     distanceToLocal(100, profile) // 100
 *
 *     const profile = { geolocation: { country: 'CA' } }
 *     distanceToLocal(100, profile) // 160
 */
export declare function distanceToLocal(distance: number, profile: Profile): number;
export declare function pipe<V1, V2, V3, R1>(fn1: (v1: V1, v2: V2, v3: V3) => R1): (v1: V1, v2: V2, v3: V3) => R1;
export declare function pipe<V1, V2, V3, R1, R2>(fn1: (v1: V1, v2: V2, v3: V3) => R1, fn2: (v: R1, v2: V2, v3: V3) => R2): (v1: V1, v2: V2, v3: V3) => R2;
export declare function pipe<V1, V2, V3, R1, R2, R3>(fn1: (v1: V1, v2: V2, v3: V3) => R1, fn2: (v: R1, v2: V2, v3: V3) => R2, fn3: (v: R2, v2: V2, v3: V3) => R3): (v1: V1, v2: V2, v3: V3) => R3;
export declare function pipe<V1, V2, V3, R1, R2, R3, R4>(fn1: (v1: V1, v2: V2, v3: V3) => R1, fn2: (v: R1, v2: V2, v3: V3) => R2, fn3: (v: R2, v2: V2, v3: V3) => R3, fn4: (v: R3, v2: V2, v3: V3) => R4): (v1: V1, v2: V2, v3: V3) => R4;
export declare function pipe<V1, V2, V3, R1, R2, R3, R4, R5>(fn1: (v1: V1, v2: V2, v3: V3) => R1, fn2: (v: R1, v2: V2, v3: V3) => R2, fn3: (v: R2, v2: V2, v3: V3) => R3, fn4: (v: R3, v2: V2, v3: V3) => R4, fn5: (v: R4, v2: V2, v3: V3) => R5): (v1: V1, v2: V2, v3: V3) => R5;
export declare function pipe<V1, V2, V3, R1, R2, R3, R4, R5, R6>(fn1: (v1: V1, v2: V2, v3: V3) => R1, fn2: (v: R1, v2: V2, v3: V3) => R2, fn3: (v: R2, v2: V2, v3: V3) => R3, fn4: (v: R3, v2: V2, v3: V3) => R4, fn5: (v: R4, v2: V2, v3: V3) => R5, fn6: (v: R5, v2: V2, v3: V3) => R6): (v1: V1, v2: V2, v3: V3) => R6;
/**
 * Returns empty object.
 *
 * Usually placed as last function in pipe, when no output required.
 *
 *     noProp(foo) // {}
 */
export declare function noProp(): {};
export declare type AllowIfFunction<T> = (value: T, profile: Profile) => T | undefined;
/**
 * Creates a function that checks whether input meets condition.
 *
 * If condition is met is returns passed value, otherwise returns undefned.
 *
 * Used when supported value needs further processing, and unsupported cancels mapping.
 *
 *     const f = allowIf(x => x === '42')
 *     f(42) // 42
 *     f(24) // undefined
 *
 * @param condition must accept input in pipe format (value, profile, params) and return boolean
 */
export declare function allowIf<T>(condition: (value: any, profile: Profile) => boolean): AllowIfFunction<T>;
export interface MakeDetails {
    name: string;
    id: string;
    models?: ModelDetails[];
}
export interface ModelDetails {
    name: string;
    id: string;
    isSeries?: boolean;
}
export interface CompoundDetails {
    make: MakeDetails;
    model?: ModelDetails;
    trim?: string;
}
export declare type GetCompoundFunction = (compound: Compound) => CompoundDetails;
/**
 * Creates a function that transforms compound values according to the compound dictionary.
 *
 * If specified make and model were not found returns undefined.
 *
 *     const makesModelsList = Object.freeze([
 *       {
 *         name: 'a',
 *         id: 'AA',
 *         models: [{ name: 'b', id: 'BB' }]
 *       }
 *     ])
 *     const f = getCompoundFromJson(makesModelsList)
 *     f({ make: 'a', model: 'b', trim: 'c' })
 *
 * Returns
 *
 *     {
 *       make: {
 *         name: 'a',
 *         id: 'AA',
 *         models: [ { name: 'b', id: 'BB' } ]
 *       },
 *       model: { name: 'b', id: 'BB' },
 *       trim: 'c'
 *     }
 *
 */
export declare function getCompoundFromJson(list: ReadonlyArray<MakeDetails>): GetCompoundFunction;
/**
 * Merges compound into a string.
 *
 *     compoundToString({ make: ' foo', model: 'bar', trim: 'baz ' }) // 'foo bar baz'
 */
export declare function compoundToString(compound: Compound): string;
export declare type MapRadiusFunction = (radius: number, profile: Profile) => number | undefined;
/**
 * Creates a function that converts input radius to the nearest supported one.
 *
 * Returned value is less than or equal to the passed radius.
 *
 * Passed radius should be the first from those mapped on specific radius.
 *
 * List of possible requested radiuses is inherited from the profile.
 *
 *     const f = M.mapRadius([ 30, 40 ]) // source supports radiuses 30 and 40
 *     f(25, apparelProfile) // undefined // there is no supported radiuses <= 25
 *     f(50, apparelProfile) // 40
 *     f(100, apparelProfile) // undefined // closest value (40) is mapped from radius 50
 */
export declare function mapRadius(supportedRadiusSteps: number[]): MapRadiusFunction;
export declare type FilterList = {
    values: ReadonlyArray<string>;
};
export declare type FilterListItem<T extends FilterList> = T['values'][number];
/**
 * Generic type that derives MappingDictionary from list filter definition.
 *
 *     filters.bar.baz = {
 *       type: 'list',
 *       values: Object.freeze(['a', 'b'])
 *     }
 *
 *     const foo: FilterMap<typeof filters.bar.baz> = {
 *       a: 'AA',
 *       b: 'BB'
 *     }
 */
export declare type FilterMap<T extends FilterList, U = string> = Record<FilterListItem<T>, U>;
/**
 * Generic type that derives MappingDictionary from a profile field type.
 *
 *     interface SomeProfile {
 *       type: ('a' | 'b')[]
 *     }
 *
 *     const mapping: ListMap<SomeProfile['type']> = {
 *       a: 'AA',
 *       b: 'BB'
 *     }
 */
export declare type ListMap<T extends string[], R = string> = Record<T[number], R>;
/**
 * Partial version of ListMap
 */
export declare type PartialListMap<T extends string[], R = string> = Partial<ListMap<T, R>>;
/**
 * Creates a function that transforms price range to array according to map.
 *
 *     const priceMap = [
 *       { min: 0, max: 100, value: 'price:$100 and below' },
 *       { min: 100, max: 500, value: 'price:$100-$500' },
 *       { min: 500, max: Infinity, value: 'price:over $500' }
 *     ]
 *     const f = priceRangeToArray(priceMap)
 *     f({ min: 200, max: 600 }) // ['price:$100-$500', 'price:over $500']
 */
export declare function priceRangeToArray(prices: {
    min: number;
    max: number;
    value: any;
}[]): ({ min, max }: {
    min: any;
    max?: number;
}) => any[];
